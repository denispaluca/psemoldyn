// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "molsimInput.hxx"

// double_vector
// 

const double_vector::x_type& double_vector::
x () const
{
  return this->x_.get ();
}

double_vector::x_type& double_vector::
x ()
{
  return this->x_.get ();
}

void double_vector::
x (const x_type& x)
{
  this->x_.set (x);
}

const double_vector::y_type& double_vector::
y () const
{
  return this->y_.get ();
}

double_vector::y_type& double_vector::
y ()
{
  return this->y_.get ();
}

void double_vector::
y (const y_type& x)
{
  this->y_.set (x);
}

const double_vector::z_type& double_vector::
z () const
{
  return this->z_.get ();
}

double_vector::z_type& double_vector::
z ()
{
  return this->z_.get ();
}

void double_vector::
z (const z_type& x)
{
  this->z_.set (x);
}


// integer_vector
// 

const integer_vector::x_type& integer_vector::
x () const
{
  return this->x_.get ();
}

integer_vector::x_type& integer_vector::
x ()
{
  return this->x_.get ();
}

void integer_vector::
x (const x_type& x)
{
  this->x_.set (x);
}

const integer_vector::y_type& integer_vector::
y () const
{
  return this->y_.get ();
}

integer_vector::y_type& integer_vector::
y ()
{
  return this->y_.get ();
}

void integer_vector::
y (const y_type& x)
{
  this->y_.set (x);
}

const integer_vector::z_type& integer_vector::
z () const
{
  return this->z_.get ();
}

integer_vector::z_type& integer_vector::
z ()
{
  return this->z_.get ();
}

void integer_vector::
z (const z_type& x)
{
  this->z_.set (x);
}


// cuboid
// 

const cuboid::position_type& cuboid::
position () const
{
  return this->position_.get ();
}

cuboid::position_type& cuboid::
position ()
{
  return this->position_.get ();
}

void cuboid::
position (const position_type& x)
{
  this->position_.set (x);
}

void cuboid::
position (::std::unique_ptr< position_type > x)
{
  this->position_.set (std::move (x));
}

const cuboid::size_type& cuboid::
size () const
{
  return this->size_.get ();
}

cuboid::size_type& cuboid::
size ()
{
  return this->size_.get ();
}

void cuboid::
size (const size_type& x)
{
  this->size_.set (x);
}

void cuboid::
size (::std::unique_ptr< size_type > x)
{
  this->size_.set (std::move (x));
}

const cuboid::distance_type& cuboid::
distance () const
{
  return this->distance_.get ();
}

cuboid::distance_type& cuboid::
distance ()
{
  return this->distance_.get ();
}

void cuboid::
distance (const distance_type& x)
{
  this->distance_.set (x);
}

const cuboid::mass_type& cuboid::
mass () const
{
  return this->mass_.get ();
}

cuboid::mass_type& cuboid::
mass ()
{
  return this->mass_.get ();
}

void cuboid::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

const cuboid::velocity_type& cuboid::
velocity () const
{
  return this->velocity_.get ();
}

cuboid::velocity_type& cuboid::
velocity ()
{
  return this->velocity_.get ();
}

void cuboid::
velocity (const velocity_type& x)
{
  this->velocity_.set (x);
}

void cuboid::
velocity (::std::unique_ptr< velocity_type > x)
{
  this->velocity_.set (std::move (x));
}


// cuboid_cluster
// 

const cuboid_cluster::cuboid_sequence& cuboid_cluster::
cuboid () const
{
  return this->cuboid_;
}

cuboid_cluster::cuboid_sequence& cuboid_cluster::
cuboid ()
{
  return this->cuboid_;
}

void cuboid_cluster::
cuboid (const cuboid_sequence& s)
{
  this->cuboid_ = s;
}


// particle
// 

const particle::x_type& particle::
x () const
{
  return this->x_.get ();
}

particle::x_type& particle::
x ()
{
  return this->x_.get ();
}

void particle::
x (const x_type& x)
{
  this->x_.set (x);
}

void particle::
x (::std::unique_ptr< x_type > x)
{
  this->x_.set (std::move (x));
}

const particle::v_type& particle::
v () const
{
  return this->v_.get ();
}

particle::v_type& particle::
v ()
{
  return this->v_.get ();
}

void particle::
v (const v_type& x)
{
  this->v_.set (x);
}

void particle::
v (::std::unique_ptr< v_type > x)
{
  this->v_.set (std::move (x));
}

const particle::m_type& particle::
m () const
{
  return this->m_.get ();
}

particle::m_type& particle::
m ()
{
  return this->m_.get ();
}

void particle::
m (const m_type& x)
{
  this->m_.set (x);
}


// particle_cluster
// 

const particle_cluster::particle_sequence& particle_cluster::
particle () const
{
  return this->particle_;
}

particle_cluster::particle_sequence& particle_cluster::
particle ()
{
  return this->particle_;
}

void particle_cluster::
particle (const particle_sequence& s)
{
  this->particle_ = s;
}


// sphere
// 

const sphere::center_type& sphere::
center () const
{
  return this->center_.get ();
}

sphere::center_type& sphere::
center ()
{
  return this->center_.get ();
}

void sphere::
center (const center_type& x)
{
  this->center_.set (x);
}

void sphere::
center (::std::unique_ptr< center_type > x)
{
  this->center_.set (std::move (x));
}

const sphere::h_type& sphere::
h () const
{
  return this->h_.get ();
}

sphere::h_type& sphere::
h ()
{
  return this->h_.get ();
}

void sphere::
h (const h_type& x)
{
  this->h_.set (x);
}

const sphere::v_type& sphere::
v () const
{
  return this->v_.get ();
}

sphere::v_type& sphere::
v ()
{
  return this->v_.get ();
}

void sphere::
v (const v_type& x)
{
  this->v_.set (x);
}

void sphere::
v (::std::unique_ptr< v_type > x)
{
  this->v_.set (std::move (x));
}

const sphere::m_type& sphere::
m () const
{
  return this->m_.get ();
}

sphere::m_type& sphere::
m ()
{
  return this->m_.get ();
}

void sphere::
m (const m_type& x)
{
  this->m_.set (x);
}

const sphere::r_type& sphere::
r () const
{
  return this->r_.get ();
}

sphere::r_type& sphere::
r ()
{
  return this->r_.get ();
}

void sphere::
r (const r_type& x)
{
  this->r_.set (x);
}


// sphere_cluster
// 

const sphere_cluster::sphere_sequence& sphere_cluster::
sphere () const
{
  return this->sphere_;
}

sphere_cluster::sphere_sequence& sphere_cluster::
sphere ()
{
  return this->sphere_;
}

void sphere_cluster::
sphere (const sphere_sequence& s)
{
  this->sphere_ = s;
}


// particle_data
// 

const particle_data::meanv_type& particle_data::
meanv () const
{
  return this->meanv_.get ();
}

particle_data::meanv_type& particle_data::
meanv ()
{
  return this->meanv_.get ();
}

void particle_data::
meanv (const meanv_type& x)
{
  this->meanv_.set (x);
}

const particle_data::is3D_type& particle_data::
is3D () const
{
  return this->is3D_.get ();
}

particle_data::is3D_type& particle_data::
is3D ()
{
  return this->is3D_.get ();
}

void particle_data::
is3D (const is3D_type& x)
{
  this->is3D_.set (x);
}

const particle_data::cuboids_type& particle_data::
cuboids () const
{
  return this->cuboids_.get ();
}

particle_data::cuboids_type& particle_data::
cuboids ()
{
  return this->cuboids_.get ();
}

void particle_data::
cuboids (const cuboids_type& x)
{
  this->cuboids_.set (x);
}

void particle_data::
cuboids (::std::unique_ptr< cuboids_type > x)
{
  this->cuboids_.set (std::move (x));
}

const particle_data::particles_type& particle_data::
particles () const
{
  return this->particles_.get ();
}

particle_data::particles_type& particle_data::
particles ()
{
  return this->particles_.get ();
}

void particle_data::
particles (const particles_type& x)
{
  this->particles_.set (x);
}

void particle_data::
particles (::std::unique_ptr< particles_type > x)
{
  this->particles_.set (std::move (x));
}

const particle_data::spheres_type& particle_data::
spheres () const
{
  return this->spheres_.get ();
}

particle_data::spheres_type& particle_data::
spheres ()
{
  return this->spheres_.get ();
}

void particle_data::
spheres (const spheres_type& x)
{
  this->spheres_.set (x);
}

void particle_data::
spheres (::std::unique_ptr< spheres_type > x)
{
  this->spheres_.set (std::move (x));
}


// boundary_type
// 

boundary_type::
boundary_type (value v)
: ::xml_schema::string (_xsd_boundary_type_literals_[v])
{
}

boundary_type::
boundary_type (const char* v)
: ::xml_schema::string (v)
{
}

boundary_type::
boundary_type (const ::std::string& v)
: ::xml_schema::string (v)
{
}

boundary_type::
boundary_type (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

boundary_type::
boundary_type (const boundary_type& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

boundary_type& boundary_type::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_boundary_type_literals_[v]);

  return *this;
}


// boundaries_type
// 

const boundaries_type::front_type& boundaries_type::
front () const
{
  return this->front_.get ();
}

boundaries_type::front_type& boundaries_type::
front ()
{
  return this->front_.get ();
}

void boundaries_type::
front (const front_type& x)
{
  this->front_.set (x);
}

void boundaries_type::
front (::std::unique_ptr< front_type > x)
{
  this->front_.set (std::move (x));
}

const boundaries_type::back_type& boundaries_type::
back () const
{
  return this->back_.get ();
}

boundaries_type::back_type& boundaries_type::
back ()
{
  return this->back_.get ();
}

void boundaries_type::
back (const back_type& x)
{
  this->back_.set (x);
}

void boundaries_type::
back (::std::unique_ptr< back_type > x)
{
  this->back_.set (std::move (x));
}

const boundaries_type::top_type& boundaries_type::
top () const
{
  return this->top_.get ();
}

boundaries_type::top_type& boundaries_type::
top ()
{
  return this->top_.get ();
}

void boundaries_type::
top (const top_type& x)
{
  this->top_.set (x);
}

void boundaries_type::
top (::std::unique_ptr< top_type > x)
{
  this->top_.set (std::move (x));
}

const boundaries_type::bottom_type& boundaries_type::
bottom () const
{
  return this->bottom_.get ();
}

boundaries_type::bottom_type& boundaries_type::
bottom ()
{
  return this->bottom_.get ();
}

void boundaries_type::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void boundaries_type::
bottom (::std::unique_ptr< bottom_type > x)
{
  this->bottom_.set (std::move (x));
}

const boundaries_type::left_type& boundaries_type::
left () const
{
  return this->left_.get ();
}

boundaries_type::left_type& boundaries_type::
left ()
{
  return this->left_.get ();
}

void boundaries_type::
left (const left_type& x)
{
  this->left_.set (x);
}

void boundaries_type::
left (::std::unique_ptr< left_type > x)
{
  this->left_.set (std::move (x));
}

const boundaries_type::right_type& boundaries_type::
right () const
{
  return this->right_.get ();
}

boundaries_type::right_type& boundaries_type::
right ()
{
  return this->right_.get ();
}

void boundaries_type::
right (const right_type& x)
{
  this->right_.set (x);
}

void boundaries_type::
right (::std::unique_ptr< right_type > x)
{
  this->right_.set (std::move (x));
}


// domain_type
// 

const domain_type::domain_size_type& domain_type::
domain_size () const
{
  return this->domain_size_.get ();
}

domain_type::domain_size_type& domain_type::
domain_size ()
{
  return this->domain_size_.get ();
}

void domain_type::
domain_size (const domain_size_type& x)
{
  this->domain_size_.set (x);
}

void domain_type::
domain_size (::std::unique_ptr< domain_size_type > x)
{
  this->domain_size_.set (std::move (x));
}

const domain_type::cutoff_radius_type& domain_type::
cutoff_radius () const
{
  return this->cutoff_radius_.get ();
}

domain_type::cutoff_radius_type& domain_type::
cutoff_radius ()
{
  return this->cutoff_radius_.get ();
}

void domain_type::
cutoff_radius (const cutoff_radius_type& x)
{
  this->cutoff_radius_.set (x);
}

const domain_type::boundary_type& domain_type::
boundary () const
{
  return this->boundary_.get ();
}

domain_type::boundary_type& domain_type::
boundary ()
{
  return this->boundary_.get ();
}

void domain_type::
boundary (const boundary_type& x)
{
  this->boundary_.set (x);
}

void domain_type::
boundary (::std::unique_ptr< boundary_type > x)
{
  this->boundary_.set (std::move (x));
}

const domain_type::gravity_optional& domain_type::
gravity () const
{
  return this->gravity_;
}

domain_type::gravity_optional& domain_type::
gravity ()
{
  return this->gravity_;
}

void domain_type::
gravity (const gravity_type& x)
{
  this->gravity_.set (x);
}

void domain_type::
gravity (const gravity_optional& x)
{
  this->gravity_ = x;
}


// molsimInput
// 

const molsimInput::name_output_optional& molsimInput::
name_output () const
{
  return this->name_output_;
}

molsimInput::name_output_optional& molsimInput::
name_output ()
{
  return this->name_output_;
}

void molsimInput::
name_output (const name_output_type& x)
{
  this->name_output_.set (x);
}

void molsimInput::
name_output (const name_output_optional& x)
{
  this->name_output_ = x;
}

void molsimInput::
name_output (::std::unique_ptr< name_output_type > x)
{
  this->name_output_.set (std::move (x));
}

const molsimInput::frequency_output_optional& molsimInput::
frequency_output () const
{
  return this->frequency_output_;
}

molsimInput::frequency_output_optional& molsimInput::
frequency_output ()
{
  return this->frequency_output_;
}

void molsimInput::
frequency_output (const frequency_output_type& x)
{
  this->frequency_output_.set (x);
}

void molsimInput::
frequency_output (const frequency_output_optional& x)
{
  this->frequency_output_ = x;
}

const molsimInput::delta_t_type& molsimInput::
delta_t () const
{
  return this->delta_t_.get ();
}

molsimInput::delta_t_type& molsimInput::
delta_t ()
{
  return this->delta_t_.get ();
}

void molsimInput::
delta_t (const delta_t_type& x)
{
  this->delta_t_.set (x);
}

const molsimInput::t_end_type& molsimInput::
t_end () const
{
  return this->t_end_.get ();
}

molsimInput::t_end_type& molsimInput::
t_end ()
{
  return this->t_end_.get ();
}

void molsimInput::
t_end (const t_end_type& x)
{
  this->t_end_.set (x);
}

const molsimInput::linked_cell_type& molsimInput::
linked_cell () const
{
  return this->linked_cell_.get ();
}

molsimInput::linked_cell_type& molsimInput::
linked_cell ()
{
  return this->linked_cell_.get ();
}

void molsimInput::
linked_cell (const linked_cell_type& x)
{
  this->linked_cell_.set (x);
}

const molsimInput::domain_type& molsimInput::
domain () const
{
  return this->domain_.get ();
}

molsimInput::domain_type& molsimInput::
domain ()
{
  return this->domain_.get ();
}

void molsimInput::
domain (const domain_type& x)
{
  this->domain_.set (x);
}

void molsimInput::
domain (::std::unique_ptr< domain_type > x)
{
  this->domain_.set (std::move (x));
}

const molsimInput::particle_data_type& molsimInput::
particle_data () const
{
  return this->particle_data_.get ();
}

molsimInput::particle_data_type& molsimInput::
particle_data ()
{
  return this->particle_data_.get ();
}

void molsimInput::
particle_data (const particle_data_type& x)
{
  this->particle_data_.set (x);
}

void molsimInput::
particle_data (::std::unique_ptr< particle_data_type > x)
{
  this->particle_data_.set (std::move (x));
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// double_vector
//

double_vector::
double_vector (const x_type& x,
               const y_type& y,
               const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

double_vector::
double_vector (const double_vector& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

double_vector::
double_vector (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void double_vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

double_vector* double_vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class double_vector (*this, f, c);
}

double_vector& double_vector::
operator= (const double_vector& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

double_vector::
~double_vector ()
{
}

// integer_vector
//

integer_vector::
integer_vector (const x_type& x,
                const y_type& y,
                const z_type& z)
: ::xml_schema::type (),
  x_ (x, this),
  y_ (y, this),
  z_ (z, this)
{
}

integer_vector::
integer_vector (const integer_vector& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  y_ (x.y_, f, this),
  z_ (x.z_, f, this)
{
}

integer_vector::
integer_vector (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  y_ (this),
  z_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void integer_vector::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      if (!x_.present ())
      {
        this->x_.set (x_traits::create (i, f, this));
        continue;
      }
    }

    // y
    //
    if (n.name () == "y" && n.namespace_ ().empty ())
    {
      if (!y_.present ())
      {
        this->y_.set (y_traits::create (i, f, this));
        continue;
      }
    }

    // z
    //
    if (n.name () == "z" && n.namespace_ ().empty ())
    {
      if (!z_.present ())
      {
        this->z_.set (z_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!y_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "y",
      "");
  }

  if (!z_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "z",
      "");
  }
}

integer_vector* integer_vector::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class integer_vector (*this, f, c);
}

integer_vector& integer_vector::
operator= (const integer_vector& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->y_ = x.y_;
    this->z_ = x.z_;
  }

  return *this;
}

integer_vector::
~integer_vector ()
{
}

// cuboid
//

cuboid::
cuboid (const position_type& position,
        const size_type& size,
        const distance_type& distance,
        const mass_type& mass,
        const velocity_type& velocity)
: ::xml_schema::type (),
  position_ (position, this),
  size_ (size, this),
  distance_ (distance, this),
  mass_ (mass, this),
  velocity_ (velocity, this)
{
}

cuboid::
cuboid (::std::unique_ptr< position_type > position,
        ::std::unique_ptr< size_type > size,
        const distance_type& distance,
        const mass_type& mass,
        ::std::unique_ptr< velocity_type > velocity)
: ::xml_schema::type (),
  position_ (std::move (position), this),
  size_ (std::move (size), this),
  distance_ (distance, this),
  mass_ (mass, this),
  velocity_ (std::move (velocity), this)
{
}

cuboid::
cuboid (const cuboid& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  position_ (x.position_, f, this),
  size_ (x.size_, f, this),
  distance_ (x.distance_, f, this),
  mass_ (x.mass_, f, this),
  velocity_ (x.velocity_, f, this)
{
}

cuboid::
cuboid (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  position_ (this),
  size_ (this),
  distance_ (this),
  mass_ (this),
  velocity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // position
    //
    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< position_type > r (
        position_traits::create (i, f, this));

      if (!position_.present ())
      {
        this->position_.set (::std::move (r));
        continue;
      }
    }

    // size
    //
    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< size_type > r (
        size_traits::create (i, f, this));

      if (!size_.present ())
      {
        this->size_.set (::std::move (r));
        continue;
      }
    }

    // distance
    //
    if (n.name () == "distance" && n.namespace_ ().empty ())
    {
      if (!distance_.present ())
      {
        this->distance_.set (distance_traits::create (i, f, this));
        continue;
      }
    }

    // mass
    //
    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      if (!mass_.present ())
      {
        this->mass_.set (mass_traits::create (i, f, this));
        continue;
      }
    }

    // velocity
    //
    if (n.name () == "velocity" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< velocity_type > r (
        velocity_traits::create (i, f, this));

      if (!velocity_.present ())
      {
        this->velocity_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!position_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "position",
      "");
  }

  if (!size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "size",
      "");
  }

  if (!distance_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "distance",
      "");
  }

  if (!mass_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "mass",
      "");
  }

  if (!velocity_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "velocity",
      "");
  }
}

cuboid* cuboid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid (*this, f, c);
}

cuboid& cuboid::
operator= (const cuboid& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->position_ = x.position_;
    this->size_ = x.size_;
    this->distance_ = x.distance_;
    this->mass_ = x.mass_;
    this->velocity_ = x.velocity_;
  }

  return *this;
}

cuboid::
~cuboid ()
{
}

// cuboid_cluster
//

cuboid_cluster::
cuboid_cluster ()
: ::xml_schema::type (),
  cuboid_ (this)
{
}

cuboid_cluster::
cuboid_cluster (const cuboid_cluster& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  cuboid_ (x.cuboid_, f, this)
{
}

cuboid_cluster::
cuboid_cluster (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  cuboid_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void cuboid_cluster::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // cuboid
    //
    if (n.name () == "cuboid" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboid_type > r (
        cuboid_traits::create (i, f, this));

      this->cuboid_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

cuboid_cluster* cuboid_cluster::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class cuboid_cluster (*this, f, c);
}

cuboid_cluster& cuboid_cluster::
operator= (const cuboid_cluster& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->cuboid_ = x.cuboid_;
  }

  return *this;
}

cuboid_cluster::
~cuboid_cluster ()
{
}

// particle
//

particle::
particle (const x_type& x,
          const v_type& v,
          const m_type& m)
: ::xml_schema::type (),
  x_ (x, this),
  v_ (v, this),
  m_ (m, this)
{
}

particle::
particle (::std::unique_ptr< x_type > x,
          ::std::unique_ptr< v_type > v,
          const m_type& m)
: ::xml_schema::type (),
  x_ (std::move (x), this),
  v_ (std::move (v), this),
  m_ (m, this)
{
}

particle::
particle (const particle& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  x_ (x.x_, f, this),
  v_ (x.v_, f, this),
  m_ (x.m_, f, this)
{
}

particle::
particle (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  x_ (this),
  v_ (this),
  m_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particle::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // x
    //
    if (n.name () == "x" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< x_type > r (
        x_traits::create (i, f, this));

      if (!x_.present ())
      {
        this->x_.set (::std::move (r));
        continue;
      }
    }

    // v
    //
    if (n.name () == "v" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< v_type > r (
        v_traits::create (i, f, this));

      if (!v_.present ())
      {
        this->v_.set (::std::move (r));
        continue;
      }
    }

    // m
    //
    if (n.name () == "m" && n.namespace_ ().empty ())
    {
      if (!m_.present ())
      {
        this->m_.set (m_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!x_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "x",
      "");
  }

  if (!v_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "v",
      "");
  }

  if (!m_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "m",
      "");
  }
}

particle* particle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle (*this, f, c);
}

particle& particle::
operator= (const particle& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->x_ = x.x_;
    this->v_ = x.v_;
    this->m_ = x.m_;
  }

  return *this;
}

particle::
~particle ()
{
}

// particle_cluster
//

particle_cluster::
particle_cluster ()
: ::xml_schema::type (),
  particle_ (this)
{
}

particle_cluster::
particle_cluster (const particle_cluster& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  particle_ (x.particle_, f, this)
{
}

particle_cluster::
particle_cluster (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  particle_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particle_cluster::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // particle
    //
    if (n.name () == "particle" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_type > r (
        particle_traits::create (i, f, this));

      this->particle_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

particle_cluster* particle_cluster::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle_cluster (*this, f, c);
}

particle_cluster& particle_cluster::
operator= (const particle_cluster& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->particle_ = x.particle_;
  }

  return *this;
}

particle_cluster::
~particle_cluster ()
{
}

// sphere
//

sphere::
sphere (const center_type& center,
        const h_type& h,
        const v_type& v,
        const m_type& m,
        const r_type& r)
: ::xml_schema::type (),
  center_ (center, this),
  h_ (h, this),
  v_ (v, this),
  m_ (m, this),
  r_ (r, this)
{
}

sphere::
sphere (::std::unique_ptr< center_type > center,
        const h_type& h,
        ::std::unique_ptr< v_type > v,
        const m_type& m,
        const r_type& r)
: ::xml_schema::type (),
  center_ (std::move (center), this),
  h_ (h, this),
  v_ (std::move (v), this),
  m_ (m, this),
  r_ (r, this)
{
}

sphere::
sphere (const sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  center_ (x.center_, f, this),
  h_ (x.h_, f, this),
  v_ (x.v_, f, this),
  m_ (x.m_, f, this),
  r_ (x.r_, f, this)
{
}

sphere::
sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  center_ (this),
  h_ (this),
  v_ (this),
  m_ (this),
  r_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // center
    //
    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< center_type > r (
        center_traits::create (i, f, this));

      if (!center_.present ())
      {
        this->center_.set (::std::move (r));
        continue;
      }
    }

    // h
    //
    if (n.name () == "h" && n.namespace_ ().empty ())
    {
      if (!h_.present ())
      {
        this->h_.set (h_traits::create (i, f, this));
        continue;
      }
    }

    // v
    //
    if (n.name () == "v" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< v_type > r (
        v_traits::create (i, f, this));

      if (!v_.present ())
      {
        this->v_.set (::std::move (r));
        continue;
      }
    }

    // m
    //
    if (n.name () == "m" && n.namespace_ ().empty ())
    {
      if (!m_.present ())
      {
        this->m_.set (m_traits::create (i, f, this));
        continue;
      }
    }

    // r
    //
    if (n.name () == "r" && n.namespace_ ().empty ())
    {
      if (!r_.present ())
      {
        this->r_.set (r_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!center_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "center",
      "");
  }

  if (!h_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "h",
      "");
  }

  if (!v_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "v",
      "");
  }

  if (!m_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "m",
      "");
  }

  if (!r_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "r",
      "");
  }
}

sphere* sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere (*this, f, c);
}

sphere& sphere::
operator= (const sphere& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->center_ = x.center_;
    this->h_ = x.h_;
    this->v_ = x.v_;
    this->m_ = x.m_;
    this->r_ = x.r_;
  }

  return *this;
}

sphere::
~sphere ()
{
}

// sphere_cluster
//

sphere_cluster::
sphere_cluster ()
: ::xml_schema::type (),
  sphere_ (this)
{
}

sphere_cluster::
sphere_cluster (const sphere_cluster& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  sphere_ (x.sphere_, f, this)
{
}

sphere_cluster::
sphere_cluster (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  sphere_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void sphere_cluster::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // sphere
    //
    if (n.name () == "sphere" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< sphere_type > r (
        sphere_traits::create (i, f, this));

      this->sphere_.push_back (::std::move (r));
      continue;
    }

    break;
  }
}

sphere_cluster* sphere_cluster::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class sphere_cluster (*this, f, c);
}

sphere_cluster& sphere_cluster::
operator= (const sphere_cluster& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->sphere_ = x.sphere_;
  }

  return *this;
}

sphere_cluster::
~sphere_cluster ()
{
}

// particle_data
//

particle_data::
particle_data (const meanv_type& meanv,
               const is3D_type& is3D,
               const cuboids_type& cuboids,
               const particles_type& particles,
               const spheres_type& spheres)
: ::xml_schema::type (),
  meanv_ (meanv, this),
  is3D_ (is3D, this),
  cuboids_ (cuboids, this),
  particles_ (particles, this),
  spheres_ (spheres, this)
{
}

particle_data::
particle_data (const meanv_type& meanv,
               const is3D_type& is3D,
               ::std::unique_ptr< cuboids_type > cuboids,
               ::std::unique_ptr< particles_type > particles,
               ::std::unique_ptr< spheres_type > spheres)
: ::xml_schema::type (),
  meanv_ (meanv, this),
  is3D_ (is3D, this),
  cuboids_ (std::move (cuboids), this),
  particles_ (std::move (particles), this),
  spheres_ (std::move (spheres), this)
{
}

particle_data::
particle_data (const particle_data& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  meanv_ (x.meanv_, f, this),
  is3D_ (x.is3D_, f, this),
  cuboids_ (x.cuboids_, f, this),
  particles_ (x.particles_, f, this),
  spheres_ (x.spheres_, f, this)
{
}

particle_data::
particle_data (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  meanv_ (this),
  is3D_ (this),
  cuboids_ (this),
  particles_ (this),
  spheres_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void particle_data::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // meanv
    //
    if (n.name () == "meanv" && n.namespace_ ().empty ())
    {
      if (!meanv_.present ())
      {
        this->meanv_.set (meanv_traits::create (i, f, this));
        continue;
      }
    }

    // is3D
    //
    if (n.name () == "is3D" && n.namespace_ ().empty ())
    {
      if (!is3D_.present ())
      {
        this->is3D_.set (is3D_traits::create (i, f, this));
        continue;
      }
    }

    // cuboids
    //
    if (n.name () == "cuboids" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< cuboids_type > r (
        cuboids_traits::create (i, f, this));

      if (!cuboids_.present ())
      {
        this->cuboids_.set (::std::move (r));
        continue;
      }
    }

    // particles
    //
    if (n.name () == "particles" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particles_type > r (
        particles_traits::create (i, f, this));

      if (!particles_.present ())
      {
        this->particles_.set (::std::move (r));
        continue;
      }
    }

    // spheres
    //
    if (n.name () == "spheres" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< spheres_type > r (
        spheres_traits::create (i, f, this));

      if (!spheres_.present ())
      {
        this->spheres_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!meanv_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "meanv",
      "");
  }

  if (!is3D_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "is3D",
      "");
  }

  if (!cuboids_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cuboids",
      "");
  }

  if (!particles_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particles",
      "");
  }

  if (!spheres_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "spheres",
      "");
  }
}

particle_data* particle_data::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class particle_data (*this, f, c);
}

particle_data& particle_data::
operator= (const particle_data& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->meanv_ = x.meanv_;
    this->is3D_ = x.is3D_;
    this->cuboids_ = x.cuboids_;
    this->particles_ = x.particles_;
    this->spheres_ = x.spheres_;
  }

  return *this;
}

particle_data::
~particle_data ()
{
}

// boundary_type
//

boundary_type::
boundary_type (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_boundary_type_convert ();
}

boundary_type::
boundary_type (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_boundary_type_convert ();
}

boundary_type::
boundary_type (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_boundary_type_convert ();
}

boundary_type* boundary_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundary_type (*this, f, c);
}

boundary_type::value boundary_type::
_xsd_boundary_type_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_boundary_type_literals_);
  const value* i (::std::lower_bound (
                    _xsd_boundary_type_indexes_,
                    _xsd_boundary_type_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_boundary_type_indexes_ + 3 || _xsd_boundary_type_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const boundary_type::
_xsd_boundary_type_literals_[3] =
{
  "outflow",
  "reflective",
  "periodic"
};

const boundary_type::value boundary_type::
_xsd_boundary_type_indexes_[3] =
{
  ::boundary_type::outflow,
  ::boundary_type::periodic,
  ::boundary_type::reflective
};

// boundaries_type
//

boundaries_type::
boundaries_type (const front_type& front,
                 const back_type& back,
                 const top_type& top,
                 const bottom_type& bottom,
                 const left_type& left,
                 const right_type& right)
: ::xml_schema::type (),
  front_ (front, this),
  back_ (back, this),
  top_ (top, this),
  bottom_ (bottom, this),
  left_ (left, this),
  right_ (right, this)
{
}

boundaries_type::
boundaries_type (const boundaries_type& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  front_ (x.front_, f, this),
  back_ (x.back_, f, this),
  top_ (x.top_, f, this),
  bottom_ (x.bottom_, f, this),
  left_ (x.left_, f, this),
  right_ (x.right_, f, this)
{
}

boundaries_type::
boundaries_type (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  front_ (this),
  back_ (this),
  top_ (this),
  bottom_ (this),
  left_ (this),
  right_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void boundaries_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // front
    //
    if (n.name () == "front" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< front_type > r (
        front_traits::create (i, f, this));

      if (!front_.present ())
      {
        this->front_.set (::std::move (r));
        continue;
      }
    }

    // back
    //
    if (n.name () == "back" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< back_type > r (
        back_traits::create (i, f, this));

      if (!back_.present ())
      {
        this->back_.set (::std::move (r));
        continue;
      }
    }

    // top
    //
    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< top_type > r (
        top_traits::create (i, f, this));

      if (!top_.present ())
      {
        this->top_.set (::std::move (r));
        continue;
      }
    }

    // bottom
    //
    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      if (!bottom_.present ())
      {
        this->bottom_.set (::std::move (r));
        continue;
      }
    }

    // left
    //
    if (n.name () == "left" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< left_type > r (
        left_traits::create (i, f, this));

      if (!left_.present ())
      {
        this->left_.set (::std::move (r));
        continue;
      }
    }

    // right
    //
    if (n.name () == "right" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< right_type > r (
        right_traits::create (i, f, this));

      if (!right_.present ())
      {
        this->right_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!front_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "front",
      "");
  }

  if (!back_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "back",
      "");
  }

  if (!top_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "top",
      "");
  }

  if (!bottom_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "bottom",
      "");
  }

  if (!left_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "left",
      "");
  }

  if (!right_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "right",
      "");
  }
}

boundaries_type* boundaries_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class boundaries_type (*this, f, c);
}

boundaries_type& boundaries_type::
operator= (const boundaries_type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->front_ = x.front_;
    this->back_ = x.back_;
    this->top_ = x.top_;
    this->bottom_ = x.bottom_;
    this->left_ = x.left_;
    this->right_ = x.right_;
  }

  return *this;
}

boundaries_type::
~boundaries_type ()
{
}

// domain_type
//

domain_type::
domain_type (const domain_size_type& domain_size,
             const cutoff_radius_type& cutoff_radius,
             const boundary_type& boundary)
: ::xml_schema::type (),
  domain_size_ (domain_size, this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_ (boundary, this),
  gravity_ (this)
{
}

domain_type::
domain_type (::std::unique_ptr< domain_size_type > domain_size,
             const cutoff_radius_type& cutoff_radius,
             ::std::unique_ptr< boundary_type > boundary)
: ::xml_schema::type (),
  domain_size_ (std::move (domain_size), this),
  cutoff_radius_ (cutoff_radius, this),
  boundary_ (std::move (boundary), this),
  gravity_ (this)
{
}

domain_type::
domain_type (const domain_type& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  domain_size_ (x.domain_size_, f, this),
  cutoff_radius_ (x.cutoff_radius_, f, this),
  boundary_ (x.boundary_, f, this),
  gravity_ (x.gravity_, f, this)
{
}

domain_type::
domain_type (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_size_ (this),
  cutoff_radius_ (this),
  boundary_ (this),
  gravity_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void domain_type::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // domain_size
    //
    if (n.name () == "domain_size" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_size_type > r (
        domain_size_traits::create (i, f, this));

      if (!domain_size_.present ())
      {
        this->domain_size_.set (::std::move (r));
        continue;
      }
    }

    // cutoff_radius
    //
    if (n.name () == "cutoff_radius" && n.namespace_ ().empty ())
    {
      if (!cutoff_radius_.present ())
      {
        this->cutoff_radius_.set (cutoff_radius_traits::create (i, f, this));
        continue;
      }
    }

    // boundary
    //
    if (n.name () == "boundary" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< boundary_type > r (
        boundary_traits::create (i, f, this));

      if (!boundary_.present ())
      {
        this->boundary_.set (::std::move (r));
        continue;
      }
    }

    // gravity
    //
    if (n.name () == "gravity" && n.namespace_ ().empty ())
    {
      if (!this->gravity_)
      {
        this->gravity_.set (gravity_traits::create (i, f, this));
        continue;
      }
    }

    break;
  }

  if (!domain_size_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain_size",
      "");
  }

  if (!cutoff_radius_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "cutoff_radius",
      "");
  }

  if (!boundary_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "boundary",
      "");
  }
}

domain_type* domain_type::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class domain_type (*this, f, c);
}

domain_type& domain_type::
operator= (const domain_type& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->domain_size_ = x.domain_size_;
    this->cutoff_radius_ = x.cutoff_radius_;
    this->boundary_ = x.boundary_;
    this->gravity_ = x.gravity_;
  }

  return *this;
}

domain_type::
~domain_type ()
{
}

// molsimInput
//

molsimInput::
molsimInput (const delta_t_type& delta_t,
             const t_end_type& t_end,
             const linked_cell_type& linked_cell,
             const domain_type& domain,
             const particle_data_type& particle_data)
: ::xml_schema::type (),
  name_output_ (this),
  frequency_output_ (this),
  delta_t_ (delta_t, this),
  t_end_ (t_end, this),
  linked_cell_ (linked_cell, this),
  domain_ (domain, this),
  particle_data_ (particle_data, this)
{
}

molsimInput::
molsimInput (const delta_t_type& delta_t,
             const t_end_type& t_end,
             const linked_cell_type& linked_cell,
             ::std::unique_ptr< domain_type > domain,
             ::std::unique_ptr< particle_data_type > particle_data)
: ::xml_schema::type (),
  name_output_ (this),
  frequency_output_ (this),
  delta_t_ (delta_t, this),
  t_end_ (t_end, this),
  linked_cell_ (linked_cell, this),
  domain_ (std::move (domain), this),
  particle_data_ (std::move (particle_data), this)
{
}

molsimInput::
molsimInput (const molsimInput& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  name_output_ (x.name_output_, f, this),
  frequency_output_ (x.frequency_output_, f, this),
  delta_t_ (x.delta_t_, f, this),
  t_end_ (x.t_end_, f, this),
  linked_cell_ (x.linked_cell_, f, this),
  domain_ (x.domain_, f, this),
  particle_data_ (x.particle_data_, f, this)
{
}

molsimInput::
molsimInput (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  name_output_ (this),
  frequency_output_ (this),
  delta_t_ (this),
  t_end_ (this),
  linked_cell_ (this),
  domain_ (this),
  particle_data_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void molsimInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // name_output
    //
    if (n.name () == "name_output" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< name_output_type > r (
        name_output_traits::create (i, f, this));

      if (!this->name_output_)
      {
        this->name_output_.set (::std::move (r));
        continue;
      }
    }

    // frequency_output
    //
    if (n.name () == "frequency_output" && n.namespace_ ().empty ())
    {
      if (!this->frequency_output_)
      {
        this->frequency_output_.set (frequency_output_traits::create (i, f, this));
        continue;
      }
    }

    // delta_t
    //
    if (n.name () == "delta_t" && n.namespace_ ().empty ())
    {
      if (!delta_t_.present ())
      {
        this->delta_t_.set (delta_t_traits::create (i, f, this));
        continue;
      }
    }

    // t_end
    //
    if (n.name () == "t_end" && n.namespace_ ().empty ())
    {
      if (!t_end_.present ())
      {
        this->t_end_.set (t_end_traits::create (i, f, this));
        continue;
      }
    }

    // linked_cell
    //
    if (n.name () == "linked_cell" && n.namespace_ ().empty ())
    {
      if (!linked_cell_.present ())
      {
        this->linked_cell_.set (linked_cell_traits::create (i, f, this));
        continue;
      }
    }

    // domain
    //
    if (n.name () == "domain" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< domain_type > r (
        domain_traits::create (i, f, this));

      if (!domain_.present ())
      {
        this->domain_.set (::std::move (r));
        continue;
      }
    }

    // particle_data
    //
    if (n.name () == "particle_data" && n.namespace_ ().empty ())
    {
      ::std::unique_ptr< particle_data_type > r (
        particle_data_traits::create (i, f, this));

      if (!particle_data_.present ())
      {
        this->particle_data_.set (::std::move (r));
        continue;
      }
    }

    break;
  }

  if (!delta_t_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "delta_t",
      "");
  }

  if (!t_end_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "t_end",
      "");
  }

  if (!linked_cell_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "linked_cell",
      "");
  }

  if (!domain_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "domain",
      "");
  }

  if (!particle_data_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "particle_data",
      "");
  }
}

molsimInput* molsimInput::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class molsimInput (*this, f, c);
}

molsimInput& molsimInput::
operator= (const molsimInput& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->name_output_ = x.name_output_;
    this->frequency_output_ = x.frequency_output_;
    this->delta_t_ = x.delta_t_;
    this->t_end_ = x.t_end_;
    this->linked_cell_ = x.linked_cell_;
    this->domain_ = x.domain_;
    this->particle_data_ = x.particle_data_;
  }

  return *this;
}

molsimInput::
~molsimInput ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::unique_ptr< ::molsimInput >
input (const ::std::string& u,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (const ::std::string& u,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (const ::std::string& u,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input (isrc, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input (isrc, h, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::input (isrc, h, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input (isrc, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       const ::std::string& sid,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input (isrc, h, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::std::istream& is,
       const ::std::string& sid,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::input (isrc, h, f, p);
}

::std::unique_ptr< ::molsimInput >
input (::xercesc::InputSource& i,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (::xercesc::InputSource& i,
       ::xml_schema::error_handler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (::xercesc::InputSource& i,
       ::xercesc::DOMErrorHandler& h,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::unique_ptr< ::molsimInput > (
    ::input (
      std::move (d), f | ::xml_schema::flags::own_dom, p));
}

::std::unique_ptr< ::molsimInput >
input (const ::xercesc::DOMDocument& doc,
       ::xml_schema::flags f,
       const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::unique_ptr< ::molsimInput > (
      ::input (
        std::move (d), f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::molsimInput > r (
      ::xsd::cxx::tree::traits< ::molsimInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

::std::unique_ptr< ::molsimInput >
input (::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > d,
       ::xml_schema::flags f,
       const ::xml_schema::properties&)
{
  ::xml_schema::dom::unique_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "input" &&
      n.namespace_ () == "")
  {
    ::std::unique_ptr< ::molsimInput > r (
      ::xsd::cxx::tree::traits< ::molsimInput, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "input",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

